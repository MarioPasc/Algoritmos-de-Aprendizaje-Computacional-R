---
title: "Algoritmos de Aprendizaje Computacional"
author: "Mario Pascual González"
format:
  html:
    theme:
      light: flatly
      dark: darkly
    highlight-style: monokai  # Monokai también funciona bien en temas oscuros
    toc: true
    toc-depth: 3
    toc-title: "Contenidos"
    toc-float:
      collapsed: false
      smooth-scroll: true
    toc_scroll: true
    number-sections: true
    code-fold: true
    code-tools: 
      source: true
      toggle: true
      caption: "Expand Code"
      
    html-math-method: katex
    bibliography: references.bib
    lang: es
    other-links:
      - text: LinkedIn
        icon: linkedin
        href: 'https://www.linkedin.com/in/mario-pascual-gonzalez/'
      - text: Correo Electrónico
        icon: envelope
        href: "mailto:mario.pg02@gmail.com?subject=Contacto desde el informe de Modelado Predictivo"
      - text: Perfil de Github
        icon: github
        href: 'https://github.com/MarioPasc'
    code-links:
      - text: Repositorio del Informe
        icon: file-code
        href: 'https://github.com/MarioPasc/Modelado-Predictivo-Cancer-de-Mama-R'
---

```{r setup}
#| output: false
#| echo: false
#| warning: false

library(glmnet)
library(caret)
library(readxl)
library(readr)
library(ggplot2)
library(dplyr)
library(broom)
library(DT)
library(tidyverse)
library(reshape2)
library(MASS)
library(pROC)
library(e1071)

data <- read.csv(file = "./data/datos_limpios.csv", sep = ",", dec=".")
data["X"] <- NULL
nuevo_orden <- c("Edad", "REst", "RPro", "Her2", "Estadio", "NodAfec", "Grado", "Fenotipo", "Estudio", "PCR")
data <- data[, nuevo_orden]
```

```{r global.options, include = TRUE}
knitr::opts_chunk$set(
    cache       = TRUE,     # if TRUE knitr will cache the results to reuse in future knits
    fig.width   = 7,       # the width for plots created by code chunk
    fig.height  = 4,       # the height for plots created by code chunk
    fig.align   = 'center', # how to align graphics in the final doc. 'left', 'right', 'center'
    fig.path    = 'figs/',  # file path to the directory where knitr shall store the graphics files
    results     = 'asis',   # knitr will pass through results without reformatting them
    echo        = TRUE,     # in FALSE knitr will not display code in the code chunk above it's results
    message     = TRUE,     # if FALSE knitr will not display any messages generated by code
    strip.white = TRUE,     # if FALSE knitr will not remove white spaces at the beg or end of code chunk
    warning     = FALSE)    # if FALSE knitr will not display any warning messages in the final document
```

# Exploración de los Datos

Los datos que con los que se tratará en este documento son datos reales clínicos, provistos por el Dr. Jose Manuel Jerez Aragonés. El fichero fue previamente pre-procesado en el proyecto anterior a este, [Modelado Predictivo para el Cáncer de Mama en R](https://github.com/MarioPasc/Modelado-Predictivo-Cancer-de-Mama-R/tree/main), y, las técnicas usadas incluyen pipelines de imputación de valores faltantes (cuantitavios con la mediana y cualitativos con la moda), manipulación de valores categóricos erróneos, eliminación de *outliers*, y otras técnicas. Es por eso que este apartado será dedicado a explorar la distribución de las variables de estos datos con la finalidad de ayudar a identificar sesgos dentro de variables que luego puedan ser mitigados mediante técnicas de validación interna de modelos. 

```{r}
convert_to_factors <- function(data, variable_list) {
  if (!is.data.frame(data)) {
    stop("El primer argumento debe ser un data.frame.")
  }
  if (!is.vector(variable_list) || !all(variable_list %in% names(data))) {
    stop("El segundo argumento debe ser un vector con nombres de columnas válidas del data.frame.")
  }
  
  for (variable_name in variable_list) {
    data[[variable_name]] <- as.factor(data[[variable_name]])
  }
  
  return(data)
}

data <- convert_to_factors(data, c("REst", "RPro", "Her2", "Estadio", "NodAfec", "Grado", "Fenotipo", "Estudio", "PCR"))

knitr::kable(head(data, 10))
```

```{r}
blue = '#377eb8'
red = '#e41a1c'
plot_variable_distribution <- function(data, variable_name, target_name) {
  # Comprobar si las variables existen en el data.frame
  if (!(variable_name %in% names(data) && target_name %in% names(data))) {
    stop("Una o ambas variables especificadas no existen en el data.frame proporcionado.")
  }
  
  # Extraer la variable y la variable target del data.frame
  variable <- data[[variable_name]]
  target <- data[[target_name]]
  
  # Asegurar que la variable target es factor
  data[[target_name]] <- as.factor(data[[target_name]])
  
  # Determinar si la variable principal es numérica o factor
  if (is.numeric(variable)) {
    # Crear un histograma para variables numéricas
    p <- ggplot(data, aes_string(x = variable_name, fill = target_name)) +
      geom_histogram(position = "identity", alpha = 0.5, bins = 30) +
      scale_fill_manual(values = c("0" = blue, "1" = red)) +
      ggtitle(paste("Distribución de", variable_name, "por", target_name)) +
      xlab(variable_name) +
      ylab("Frecuencia")
  } else if (is.factor(variable)) {
    # Crear un gráfico de barras para factores
    p <- ggplot(data, aes_string(x = variable_name, fill = target_name)) +
      geom_bar(position = "stack") +
      scale_fill_manual(values = c("0" = blue, "1" = red)) +
      ggtitle(paste("Distribución de", variable_name, "por", target_name)) +
      xlab(variable_name) +
      ylab("Frecuencia") +
      theme(legend.position = "right")
  } else {
    stop("El tipo de la variable debe ser numérico o factor.")
  }
  
  # Imprimir el gráfico
  print(p)
}

```

::: {.panel-tabset}

## Edad

```{r}
plot_variable_distribution(data, "Edad", "PCR")
```

## REst

```{r}
plot_variable_distribution(data, "REst", "PCR")
```

## RPro

```{r}
plot_variable_distribution(data, "RPro", "PCR")
```

## Her2

```{r}
plot_variable_distribution(data, "Her2", "PCR")
```

## Estadio

```{r}
plot_variable_distribution(data, "Estadio", "PCR")
```

## NodAfec

```{r}
plot_variable_distribution(data, "NodAfec", "PCR")
```

## Grado

```{r}
plot_variable_distribution(data, "Grado", "PCR")
```

## Fenotipo

```{r}
plot_variable_distribution(data, "Fenotipo", "PCR")
```

## Estudio

```{r}
plot_variable_distribution(data, "Estudio", "PCR")
```

## PCR

```{r}
plot_variable_distribution(data, "PCR", "PCR")
```

:::

Como se puede observar en las gráficas anteriores, el conjunto de datos se encuentra **desbalanceado** con respecto a la variable objetivo, PCR, a lo largo de todas las demás variables del conjunto de datos. Esto se evidencia al visualizar la propia distribución de la variable PCR, la cual muestra la falta de entradas positivas, algo normal en los estudios clínicos en los que una connotación negativa está asociada a la muestra positiva -en este caso, la metástasis del cáncer. 

Observando el resto de gráficas, se pueden notar otros fenómenos que podrían introducir un sesgo en nuestros datos. La variable `Her2`, por ejemplo, se encuentra totalmente desbalanceada, teniendo una cantidad ínfima de muestras para Her2-Positivo. Para poder tener en cuenta cómo estos datos se relacionan con la variable objetivo, y así poder determinar si la excasa cantidad de estos afecta de una manera muy negativa la predicción de nuestro modelo, se realizará un *análisis de asociación*. 

# Selección de características

## Análisis de Asociación

```{r, warning=FALSE, message=FALSE}
source("./aux_scripts/calculaPValor.R")
plot_p_valores(data)

```

Como se puede observar en la salida del modelo de regresión logística, las variables que muestran una asociación estadísticamente significativa con la variable objetivo PCR son **Estadio, Fenotipo, Grado, REst, y RPro**. Estas variables han sido seleccionadas mediante un proceso iterativo que utiliza el algoritmo `stepAIC`, el cual optimiza el modelo añadiendo o eliminando variables para minimizar el criterio de información de Akaike (AIC). Este enfoque no solo confirma la significancia estadística inicial observada en los análisis de p-valores, sino que también ajusta el modelo para incluir solo las variables más informativas.

```{r}
source("./aux_scripts/calculaPValor.R")

ajustado <- ajustarModeloLogistico(data, "PCR", "Estadio + Fenotipo + Grado + REst + RPro")
asociacion <- c("Estadio", "Fenotipo", "Grado", "REst", "RPro")
variables_seleccionadas <- ajustado$variables_seleccionadas
```

El modelo final selecciona múltiples categorías dentro de las variables Estadio, Fenotipo, Grado, REst, y RPro que son determinantes para explicar la variable PCR. Estas categorías incluyen, por ejemplo, diferentes tipos de Estadio y Fenotipo, que muestran cómo varía la probabilidad de PCR en función de estas características. Este conjunto de variables y categorías será denominado de ahora en adelante como Asociacion, en referencia al método efectivo de selección de variables utilizado.

# Modelos Predictivos Avanzados

El principal objetivo de este proyecto es el de poder predecir si un paciente será PCR-Positivo (Metástasis) mediante el uso de Algoritmos de Aprendizaje Computacional para el procesamiento de los datos de cáncer de mama previamente curados. Para poder conseguir el modelo que más se ajuste a esta tarea, se debe realizar una selección de características sobre el conjunto de datos y un ajuste fino (*fine-tuning*) de los parámetros del modelo de predicción. Todo esto debe ser llevado a cabo utilizando métodos de validación interna que eliminen cualquier tipo de sesgo inherente dentro de los datos en la variable objetivo, asegurando unos resultados estables para la evaluación del rendimiento del modelo para datos a futuro.  


## SVM

```{r}
# Suponiendo que 'data' es tu dataframe y 'PCR' es la columna objetivo
set.seed(123)  # Para reproducibilidad
indices <- createDataPartition(data$PCR, p = 0.80, list = TRUE)
train_data <- data[indices[[1]], ]
test_data <- data[-indices[[1]], ]

# Modelo SVM básico
svm_model <- svm(PCR ~ ., data = train_data, kernel = "radial", probability = TRUE)

# Predicción con el modelo
predicciones <- predict(svm_model, test_data, probability = TRUE)

# Extraer probabilidades y crear un factor binario basado en el umbral
probabilidades <- attr(predicciones, "probabilities")[,2]
predicciones_truncadas <- ifelse(probabilidades < 0.5, 0, 1)

# Función para calcular métricas
calcular_metricas <- function(target, predicciones_truncadas) {
  TP <- sum(predicciones_truncadas == 1 & target == 1)
  TN <- sum(predicciones_truncadas == 0 & target == 0)
  FP <- sum(predicciones_truncadas == 1 & target == 0)
  FN <- sum(predicciones_truncadas == 0 & target == 1)

  Accuracy <- (TP + TN) / (TP + TN + FN + FP)
  Precision <- ifelse(TP + FP == 0, 0, TP / (TP + FP))
  Recall <- ifelse(TP + FN == 0, 0, TP / (TP + FN))
  F1score <- ifelse(Precision + Recall == 0, 0, (2 * Precision * Recall) / (Precision + Recall))

  df_metricas_rendimiento <- data.frame(
    Metric = c("Accuracy", "Precision", "Recall", "F1 Score"),
    Value = c(Accuracy, Precision, Recall, F1score)
  )

  df_rates <- data.frame(
    Metric = c("True Positives", "True Negatives", "False Positives", "False Negatives"),
    Value = c(TP, TN, FP, FN)
  )

  list(
    Metrics = df_metricas_rendimiento,
    Rates = df_rates
  )
}

# Calcular métricas
resultado_metricas <- calcular_metricas(test_data$PCR, predicciones_truncadas)

# Imprimir resultados
print(resultado_metricas$Metrics)
print(resultado_metricas$Rates)

```


